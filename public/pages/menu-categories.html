<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Menu Categories | FoodBao Admin</title>
    
    <!-- Early session check script - Must be first script loaded -->
    <script>
    // Enhanced session verification - inline for fastest possible execution
    (function() {
        try {
            // Check session storage first (higher priority), then localStorage
            const sessionKey = sessionStorage.getItem('session_key') || localStorage.getItem('session_key');
            const authToken = sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token');
            const sessionTimestamp = sessionStorage.getItem('session_timestamp') || localStorage.getItem('session_timestamp');
            const currentTime = new Date().getTime();
            
            // Prevent back navigation after logout by replacing history state
            history.replaceState(null, document.title, location.href);
            
            // Force reload on back button navigation to ensure fresh session check
            window.addEventListener('pageshow', function(event) {
                if (event.persisted) {
                    // This catches bfcache navigation in all browsers
                    window.location.reload();
                }
            });
            
            // Comprehensive session validation logic
            if (!sessionKey || !authToken || 
                !sessionTimestamp || 
                (currentTime - parseInt(sessionTimestamp)) > (24 * 60 * 60 * 1000)) { // 24 hour max session
                // Hide content immediately to prevent UI flashing
                document.documentElement.style.display = 'none';
                // Redirect with cache-busting parameter
                const redirectUrl = '/login.html?expired=true&nocache=' + new Date().getTime();
                window.location.replace(redirectUrl);
                throw new Error('Session invalid or expired');
            }
            
            // Advanced visibility change detection
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'visible') {
                    performFullSessionCheck();
                }
            });
            
            function performFullSessionCheck() {
                const currentSessionKey = sessionStorage.getItem('session_key') || localStorage.getItem('session_key');
                const currentAuthToken = sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token');
                const currentTimestamp = sessionStorage.getItem('session_timestamp') || localStorage.getItem('session_timestamp');
                const now = new Date().getTime();
                
                if (!currentSessionKey || !currentAuthToken || 
                    !currentTimestamp || 
                    (now - parseInt(currentTimestamp)) > (24 * 60 * 60 * 1000)) {
                    document.documentElement.style.display = 'none';
                    sessionStorage.clear();
                    localStorage.removeItem('session_key');
                    localStorage.removeItem('auth_token');
                    localStorage.removeItem('session_timestamp');
                    const redirectUrl = '/login.html?expired=true&nocache=' + now;
                    window.location.replace(redirectUrl);
                }
            }
            
            // Set initial check point
            sessionStorage.setItem('last_activity', currentTime.toString());
            if (localStorage.getItem('session_key')) {
                localStorage.setItem('session_timestamp', currentTime.toString());
            }
        } catch (e) {
            // Fail safe: redirect to login on any error
            console.error('Session verification failed:', e);
            document.documentElement.style.display = 'none';
            sessionStorage.clear();
            localStorage.removeItem('session_key');
            localStorage.removeItem('auth_token');
            localStorage.removeItem('session_timestamp');
            window.location.replace('/login.html?error=true&nocache=' + new Date().getTime());
        }
    })();
    </script>
    
    <!-- Add this script block before your other scripts but after the early session check -->
    <script>
    // Idle timeout and enhanced session management
    (function() {
        const IDLE_TIMEOUT = 30 * 60 * 1000; // 30 minutes in milliseconds
        let idleTimer;
        
        // Reset the idle timer whenever user activity is detected
        function resetIdleTimer() {
            clearTimeout(idleTimer);
            const currentTime = new Date().getTime();
            sessionStorage.setItem('last_activity', currentTime.toString());
            
            // Update session timestamp periodically while active
            if (localStorage.getItem('session_key')) {
                localStorage.setItem('session_timestamp', currentTime.toString());
            }
            
            idleTimer = setTimeout(logoutDueToInactivity, IDLE_TIMEOUT);
        }
        
        // Handle logout due to user inactivity
        function logoutDueToInactivity() {
            console.log("User inactive for too long. Logging out...");
            showIdleTimeoutMessage();
            performSecureLogout();
        }
        
        // Show a message to the user that they're being logged out due to inactivity
        function showIdleTimeoutMessage() {
            // You can implement a modal/toast here if needed
            alert("You have been logged out due to inactivity for security purposes.");
        }
        
        // Secure logout function that clears all auth data and prevents back navigation
        window.performSecureLogout = function() {
            // Clear all authentication data
            sessionStorage.clear();
            localStorage.removeItem('session_key');
            localStorage.removeItem('auth_token');
            localStorage.removeItem('session_timestamp');
            localStorage.removeItem('user_data');
            
            // Add cache-busting parameter and use replace to prevent back button
            const logoutTime = new Date().getTime();
            
            // Clear any cookies that might be related to authentication
            document.cookie.split(";").forEach(function(c) {
                document.cookie = c.replace(/^ +/, "")
                    .replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
            });
            
            // Use post-logout cleanup and navigation prevention
            try {
                // This helps avoid bfcache issues in various browsers
                window.history.replaceState(null, document.title, window.location.href);
                window.history.pushState(null, document.title, window.location.href);
                window.history.go(1);
                
                // Hide content immediately to prevent UI flashing
                document.documentElement.style.display = 'none';
            } catch (e) {
                console.error("Error during history manipulation:", e);
            }
            
            // Final redirect with cache busting
            window.location.replace('/login.html?logged_out=true&nocache=' + logoutTime);
        }
        
        // Set up event listeners for user activity
        const activityEvents = [
            'mousedown', 'mousemove', 'keydown', 
            'scroll', 'touchstart', 'click', 'keypress'
        ];
        
        activityEvents.forEach(eventName => {
            document.addEventListener(eventName, resetIdleTimer, { passive: true });
        });
        
        // Initialize the idle timer when the script loads
        resetIdleTimer();
        
        // Periodically check session validity (every minute)
        setInterval(function() {
            const lastActivity = parseInt(sessionStorage.getItem('last_activity') || '0');
            const currentTime = new Date().getTime();
            
            if ((currentTime - lastActivity) > IDLE_TIMEOUT) {
                logoutDueToInactivity();
            }
        }, 60000); // Check every minute
    })();
    </script>
    
    <!-- Regular session check script for additional validation -->
    <script src="../utils/session-check.js"></script>
      <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="../css/materialize.min.css" rel="stylesheet">
    <link href="../css/fullscreen-camera.css" rel="stylesheet">
    <!-- Compact UI styles -->
    <link rel="stylesheet" href="../css/compact-ui.css">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --accent-color: #f39c12;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --danger-color: #e74c3c;
            --warning-color: #f1c40f;
        }
        
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            font-size: 14px;
        }
        
        /* Remove all padding for better space utilization */
        .container {
            padding: 0 !important;
            max-width: 100%;
            width: 100%;
        }
        
        /* Standardized header style */
        .dashboard-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 0.5rem !important;
            margin: 0 !important;
            position: sticky;
            top: 0;
            z-index: 1000;
            border-radius: 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .dashboard-header h2 {
            font-size: 1.3rem;
            margin: 0;
            line-height: 1.2;
        }
        
        .dashboard-header p {
            font-size: 0.8rem;
            margin: 0;
            opacity: 0.8;
        }
        
        /* Flat card styles */
        .card {
            border-radius: 0;
            margin: 0;
            box-shadow: none;
            background-color: transparent;
        }
        
        .card-header {
            padding: 0.4rem;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            background-color: white;
        }
        
        .card-header h5, .card-header h6 {
            font-size: 0.9rem;
            margin: 0;
        }
        
        .card-body {
            padding: 0 !important;
        }
        
        /* Grid layout for categories */
        .categories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 0;
            margin: 0;
            padding: 0;
        }
        
        /* Style categories with image backgrounds */
        .category-card {
            position: relative;
            height: 110px;
            margin: 0;
            padding: 0;
            overflow: hidden;
            border: 1px solid #f5f5f5;
            transition: all 0.2s ease;
        }
        
        .category-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .category-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            filter: brightness(0.7);
            z-index: 1;
        }
        
        .category-info {
            position: relative;
            z-index: 2;
            padding: 8px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .category-id {
            font-size: 0.65rem;
            opacity: 0.8;
        }
        
        .category-name {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .category-description {
            font-size: 0.7rem;
            opacity: 0.9;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .category-actions {
            position: absolute;
            bottom: 5px;
            right: 5px;
            z-index: 3;
            display: flex;
            gap: 3px;
        }
        
        .category-actions .btn {
            width: 24px;
            height: 24px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            border-radius: 3px;
            background-color: rgba(255, 255, 255, 0.8);
        }
        
        /* Floating button styles */
        .floating-btn {
            position: fixed;
            bottom: 12px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.25);
            border: none;
            font-size: 16px;
            z-index: 1000;
            transition: all 0.2s;
        }
        
        .floating-btn:hover {
            transform: scale(1.1);
        }
        
        .floating-btn-back {
            left: 12px;
            background-color: var(--primary-color);
        }
        
        .floating-btn-add {
            right: 12px;
            background-color: var(--secondary-color);
        }
        
        /* Modal styles with matching theme - REMOVED */
        
        .btn-close-white {
            filter: brightness(0) invert(1);
            padding: 0.25rem;
            font-size: 0.8rem;
        }
        
        /* Status badge for categories */
        .status-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            z-index: 3;
            font-size: 0.65rem;
            padding: 1px 4px;
            border-radius: 3px;
        }
        
        .status-active {
            background-color: rgba(46, 204, 113, 0.8);
            color: white;
        }
        
        .status-inactive {
            background-color: rgba(231, 76, 60, 0.8);
            color: white;
        }
        
        /* Loading and empty states */
        #categoriesLoadingSpinner, #emptyCategoriesState {
            padding: 15px !important;
            text-align: center;
            font-size: 0.85rem;
        }
        
        /* Make modals fullscreen on mobile */
        @media (max-width: 576px) {
            .modal-dialog {
                margin: 0;
                max-width: 100%;
                height: 100%;
            }
            
            .modal-content {
                height: 100%;
                border: 0;
                border-radius: 0;
            }
            
            .modal-body {
                overflow-y: auto;
            }
            
            /* Adjust camera/photo frame size */
            #cameraCapture {
                width: 100%;
                height: auto;
                max-height: 50vh;
                object-fit: cover;
            }
            
            .image-preview {
                width: 100%;
                height: 150px;
                overflow: hidden;
                display: flex;
                align-items: center;
                justify-content: center;
                background-color: #f5f5f5;
                border-radius: 4px;
                border: 1px solid #dee2e6;
            }
            
            .image-preview img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }
            
            /* Decrease footer button sizes */
            .modal-footer {
                padding: 8px;
            }
            
            .modal-footer .btn {
                font-size: 0.8rem;
                padding: 0.25rem 0.5rem;
            }
            
            /* Smaller categories on mobile */
            .categories-grid {
                grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            }
            
            .category-card {
                height: 90px;
            }
            
            .category-description {
                display: none;
            }
        }
        
        /* Even smaller on very small screens */
        @media (max-width: 360px) {
            .categories-grid {
                grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            }
            
            .category-card {
                height: 80px;
            }
            
            .category-name {
                font-size: 0.8rem;
            }
        }

        /* List layout styles (matching menu-items page) */
        .category-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        /* Tiny Toast Styles */
        .tiny-toast {
            max-width: 280px;
            font-size: 0.75rem;
            padding: 0.3rem;
            border-radius: 4px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        
        .tiny-toast.bg-success {
            background-color: rgba(46, 204, 113, 0.9) !important;
        }
        
        .tiny-toast.bg-danger {
            background-color: rgba(231, 76, 60, 0.9) !important;
        }
        
        .toast-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .toast-content {
            flex-grow: 1;
            line-height: 1.2;
        }
        
        .category-item {
            display: flex;
            background-color: white;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .category-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.12);
        }
        
        .category-image {
            width: 80px;
            height: 80px;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }
        
        .category-details {
            padding: 10px;
            display: flex;
            flex-grow: 1;
            align-items: center;
        }
        
        .category-main-info {
            flex-grow: 1;
        }
        
        .category-title {
            font-size: 1rem;
            font-weight: 500;
            color: var(--dark-color);
            display: flex;
            align-items: center;
        }
        
        .category-order-compact {
            background-color: var(--primary-color);
            color: white;
            font-size: 0.7rem;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .category-desc {
            color: #666;
            font-size: 0.8rem;
            margin: 2px 0 0 0;
        }
        
        .category-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 8px;
            display: inline-block;
        }
        
        .category-status.active {
            background-color: var(--secondary-color);
        }
        
        .category-status.inactive {
            background-color: var(--danger-color);
        }
        
        /* Category actions - Updated to match menu-items style */
        .category-actions {
            display: flex;
            gap: 5px;
            margin-left: auto;
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            z-index: 5;
            opacity: 1;
        }
        
        .category-action-compact {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background-color: #f8f9fa;
            color: #444;
            transition: all 0.2s;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .action-edit-compact:hover {
            background-color: var(--primary-color);
            color: white;
        }
        
        .action-delete-compact:hover {
            background-color: var(--danger-color);
            color: white;
        }

        /* Ensure buttons are always visible on mobile */
        @media (max-width: 576px) {
            .category-action-compact {
                width: 32px;
                height: 32px;
            }
            
            .category-actions {
                position: absolute;
                top: 50%;
                right: 10px;
                transform: translateY(-50%);
                opacity: 1;
            }
        }

        /* Item Detail Modal styling matching menu.html */
        .category-detail-modal {
            max-width: 95% !important; /* Set modal width to 95% of viewport */
            width: 95%; /* Ensure the width is enforced */
            margin: 10px auto; /* Keep centered with some margin */
        }

        .category-detail-modal .modal-content {
            border-radius: 5px;
            overflow: hidden;
            padding: 0;
            width: 100%;
        }

        .category-detail-content {
            padding: 15px;
        }

        /* Modal dialog centered with larger space */
        .modal-dialog-centered {
            display: flex;
            align-items: center;
            min-height: calc(100% - 1rem);
        }

        /* Full frame modal styles */
        .full-frame-modal {
            position: fixed;
            top: 2.5%;
            left: 2.5%;
            width: 95%;
            height: 95%;
            background-color: #fff;
            z-index: 2000;
            display: none;
            overflow-y: auto;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .full-frame-modal.show {
            display: block;
        }

        .full-frame-modal-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 2001;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
        }

        .full-frame-modal-body {
            padding: 20px;
        }

        .full-frame-modal-footer {
            padding: 15px 20px;
            background-color: #f8f9fa;
            border-top: 1px solid #dee2e6;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            position: sticky;
            bottom: 0;
            z-index: 2001;
        }

        /* Hide Bootstrap modal backdrop */
        .modal-backdrop {
            display: none;
        }

        /* Image preview enhancement for full frame */
        .image-preview {
            width: 100%;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .image-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Full-screen camera modal */
        .fullscreen-camera-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #000;
            z-index: 3000;
            display: none;
        }
        
        .fullscreen-camera {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .camera-header {
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 3001;
        }
        
        .camera-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            padding: 20px;
            z-index: 3001;
        }
        
        .capture-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: white;
            border: 2px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .flip-camera-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .close-camera-btn {
            background: rgba(255,255,255,0.3);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* Loading animation for image upload */
        .loading-animation {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        .loading-animation .spinner {
            margin-bottom: 10px;
        }

        .loading-animation .message {
            color: #666;
            text-align: center;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container py-4">
        <!-- Dashboard Header -->
        <div class="dashboard-header mb-4">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h2 class="mb-0">Menu Categories</h2>
                    <p class="mb-0">Manage your food and beverage categories</p>
                </div>
                <div class="col-md-4 text-md-end">
                    <p class="mb-0">Last updated: <span id="lastUpdated">Apr 3, 2025</span></p>
                </div>
            </div>
        </div>
        
        <!-- Statistics Section -->
        <div class="card mb-4">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="card-title mb-0">Categories</h5>
                <!-- Replace your current stats container with this simplified version -->
                <div class="stats-container d-flex text-muted small">
                    <div class="me-3">
                        <i class="fas fa-list-ul me-1"></i> <span id="totalCategories">0</span>
                    </div>
                    <div class="me-3">
                        <i class="fas fa-check-circle me-1 text-success"></i> <span id="activeCategories">0</span>
                    </div>
                    <div>
                        <i class="fas fa-times-circle me-1 text-danger"></i> <span id="inactiveCategories">0</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Loading Spinner -->
        <div id="loadingSpinner" class="text-center my-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Loading categories...</p>
        </div>
        
        <!-- Empty State (shown when no categories) -->
        <div id="emptyState" class="empty-state d-none">
            <div class="empty-icon">
                <i class="fas fa-list-ul"></i>
            </div>
            <h4>No Categories Found</h4>
            <p class="text-muted">Get started by creating your first menu category</p>
            <button class="btn btn-primary mt-3" onclick="openCategoryModal()">
                <i class="fas fa-plus me-2"></i>Add Category
            </button>
        </div>
        
        <!-- Categories Grid -->
        <div class="row g-4" id="categoriesContainer">
            <!-- Categories will be populated here via JavaScript -->
        </div>

        <div class="modal fade" id="categoryModal" tabindex="-1" aria-labelledby="categoryModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered item-detail-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="categoryModalLabel">Add Category</h5>
                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <form id="categoryForm">
                            <input type="hidden" id="categoryId">
                            
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="form-group">
                                        <label for="categoryName">Category Name</label>
                                        <input type="text" class="form-control" id="categoryName" required placeholder="e.g. Main Courses">
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="categoryDescription">Description</label>
                                        <textarea class="form-control" id="categoryDescription" rows="3" placeholder="Describe this category..."></textarea>
                                    </div>
                                    
                                    <div class="row"></div>
                                        <div class="col-md-6">
                                            <div class="form-group">
                                                <label for="displayOrder">Display Order</label>
                                                <input type="number" class="form-control" id="displayOrder" min="1" value="1">
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="form-group">
                                                <label for="isActive">Status</label>
                                                <select class="form-select" id="isActive">
                                                    <option value="true">Active</option>
                                                    <option value="false">Inactive</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="col-md-6">
                                    <div class="form-group">
                                        <label>Category Image</label>
                                        <div class="image-preview" id="imagePreview">
                                            <div class="image-preview-placeholder">
                                                <i class="fas fa-image fa-3x mb-2"></i>
                                                <p>No image selected</p>
                                            </div>
                                        </div>
                                        
                                        <div class="d-flex">
                                            <div class="input-group mb-3 me-2">
                                                <input type="file" class="form-control" id="imageUpload" accept="image/*">
                                            </div>
                                            <button type="button" class="btn btn-outline-primary" onclick="activateCamera()">
                                                <i class="fas fa-camera"></i>
                                            </button>
                                        </div>
                                        <video id="cameraCapture" class="camera-capture"></video>
                                        <div id="cameraBtns" class="d-none">
                                            <button type="button" class="btn btn-primary w-100" id="takePhotoBtn">
                                                <i class="fas fa-camera me-2"></i>Take Photo
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <input type="hidden" id="imageBase64">
                            
                            <div class="d-flex justify-content-end mt-4 category-detail-content">
                                <button type="button" class="btn btn-outline-secondary me-2" data-bs-dismiss="modal">Cancel</button>
                                <button type="submit" class="btn btn-success" id="saveBtn">
                                    <i class="fas fa-save me-2"></i>Save Category
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Delete Confirmation Modal -->
        <div class="modal fade" id="deleteModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header bg-danger text-white">
                        <h5 class="modal-title">Confirm Deletion</h5>
                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p>Are you sure you want to delete the category "<span id="deleteCategoryName"></span>"?</p>
                        <p class="text-muted">This action cannot be undone. All menu items in this category may be affected.</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-danger" id="confirmDeleteBtn">
                            <i class="fas fa-trash me-2"></i>Delete Category
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Full Frame Category Edit Modal -->
    <div id="fullFrameCategoryModal" class="full-frame-modal">
        <div class="full-frame-modal-header">
            <h5 class="full-frame-modal-title" id="fullFrameCategoryTitle">Edit Category</h5>
            <button type="button" class="full-frame-modal-close" id="closeFullFrameModal">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="full-frame-modal-body">
            <form id="fullFrameCategoryForm">
                <input type="hidden" id="fullFrameCategoryId">
                
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group mb-3">
                            <label for="fullFrameCategoryName" class="form-label">Category Name</label>
                            <input type="text" class="form-control" id="fullFrameCategoryName" required placeholder="e.g. Main Courses">
                        </div>
                        
                        <div class="form-group mb-3">
                            <label for="fullFrameCategoryDescription" class="form-label">Description</label>
                            <textarea class="form-control" id="fullFrameCategoryDescription" rows="3" placeholder="Describe this category..."></textarea>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="fullFrameDisplayOrder" class="form-label">Display Order</label>
                                    <input type="number" class="form-control" id="fullFrameDisplayOrder" min="1" value="1">
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="fullFrameIsActive" class="form-label">Status</label>
                                    <select class="form-select" id="fullFrameIsActive">
                                        <option value="true">Active</option>
                                        <option value="false">Inactive</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="form-group mb-3">
                            <label class="form-label">Category Image</label>
                            <div class="image-preview" id="fullFrameImagePreview">
                                <div class="image-preview-placeholder">
                                    <i class="fas fa-image fa-3x mb-2"></i>
                                    <p>No image selected</p>
                                </div>
                            </div>
                            
                            <div class="d-flex mt-2">
                                <div class="input-group me-2">
                                    <input type="file" class="form-control" id="fullFrameImageUpload" accept="image/*">
                                </div>
                                <button type="button" class="btn btn-outline-primary" onclick="activateFullFrameCamera()">
                                    <i class="fas fa-camera"></i>
                                </button>
                            </div>
                            <video id="fullFrameCameraCapture" class="camera-capture w-100 mt-2" style="display: none;"></video>
                            <div id="fullFrameCameraBtns" class="d-none mt-2">
                                <button type="button" class="btn btn-primary w-100" id="fullFrameTakePhotoBtn">
                                    <i class="fas fa-camera me-2"></i>Take Photo
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <input type="hidden" id="fullFrameImageBase64">
            </form>
        </div>
        <div class="full-frame-modal-footer">
            <button type="button" class="btn btn-outline-secondary" id="cancelFullFrameModal">Cancel</button>
            <button type="button" class="btn btn-success" id="saveFullFrameCategory">
                <i class="fas fa-save me-2"></i>Save Category
            </button>
        </div>
    </div>

    <!-- Full Frame Delete Confirmation Modal -->
    <div id="fullFrameDeleteModal" class="full-frame-modal">
        <div class="full-frame-modal-header bg-danger text-white">
            <h5 class="full-frame-modal-title">Confirm Deletion</h5>
            <button type="button" class="full-frame-modal-close" id="closeFullFrameDeleteModal">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="full-frame-modal-body">
            <div class="text-center mb-4">
                <i class="fas fa-exclamation-triangle text-danger" style="font-size: 4rem;"></i>
            </div>
            <h4 class="text-center mb-3">Are you sure you want to delete this category?</h4>
            <p class="text-center mb-4">Category: "<span id="fullFrameDeleteCategoryName" class="fw-bold"></span>"</p>
            <div class="alert alert-warning">
                <i class="fas fa-exclamation-circle me-2"></i>
                This action cannot be undone. All menu items in this category may be affected.
            </div>
        </div>
        <div class="full-frame-modal-footer">
            <button type="button" class="btn btn-outline-secondary" id="cancelFullFrameDeleteModal">Cancel</button>
            <button type="button" class="btn btn-danger" id="confirmFullFrameDeleteBtn">
                <i class="fas fa-trash me-2"></i>Delete Category
            </button>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="position-fixed bottom-0 end-0 p-2" style="z-index: 1100">
        <div id="toast" class="toast tiny-toast" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex align-items-center">
                <div class="toast-icon me-2">
                    <i id="toastIcon" class="fas fa-info-circle"></i>
                </div>
                <div class="toast-content">
                    <small id="toastMessage">Notification message</small>
                </div>
                <button type="button" class="btn-close btn-close-white ms-2" style="font-size: 0.65rem;" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    </div>

    <!-- Floating buttons -->
    <button class="floating-btn floating-btn-back" onclick="window.location.href='../index.html'" title="Back to Dashboard">
        <i class="fas fa-arrow-left"></i>
    </button>

    <button class="floating-btn floating-btn-add" onclick="openCategoryModal()" title="Add New Category">
        <i class="fas fa-plus"></i>
    </button>

    <!-- Added Bootstrap and Popper.js scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>

    <!-- Camera Modal and Cloudinary Scripts -->
    <script src="../js/cloudinary-credentials.js"></script>
    <script src="../js/cloudinary-operations.js"></script>
    <script src="../js/camera-modal.js"></script>

    <script>
        // Debug API Tracker - Enhanced version
        const debugTracker = {
            enabled: true,
            historyEnabled: true,
            history: [],
            maxHistoryItems: 20,
            
            log: function(area, message, data = null) {
                if (!this.enabled) return;
                
                const timestamp = new Date().toLocaleTimeString();
                console.log(`%c[DEBUG ${timestamp}][${area}] ${message}`, 'background: #222; color: #bada55');
                if (data !== null) {
                    console.log('%cData:', 'color: #bada55', data);
                }
                
                this.addToHistory('debug', area, message, data);
            },
            
            error: function(area, message, error = null) {
                if (!this.enabled) return;
                
                const timestamp = new Date().toLocaleTimeString();
                console.error(`%c[ERROR ${timestamp}][${area}] ${message}`, 'background: #222; color: #ff6347');
                if (error !== null) {
                    console.error('%cError details:', 'color: #ff6347', error);
                }
                
                this.addToHistory('error', area, message, error);
            },
            
            request: function(method, url, data = null) {
                if (!this.enabled) return;
                
                const timestamp = new Date().toLocaleTimeString();
                console.log(
                    `%c[${timestamp}][API Request] ${method} ${url}`, 
                    'background: #0066cc; color: white; padding: 2px 5px; border-radius: 3px;'
                );
                if (data !== null) {
                    console.log('%cRequest payload:', 'color: #0066cc', data);
                }
                
                this.addToHistory('request', method + ' ' + url, null, data);
            },
            
            response: function(method, url, status, data = null) {
                if (!this.enabled) return;
                
                const isSuccess = status >= 200 && status < 300;
                const timestamp = new Date().toLocaleTimeString();
                
                console.log(
                    `%c[${timestamp}][API Response] ${method} ${url} (Status: ${status})`, 
                    `background: ${isSuccess ? '#28a745' : '#dc3545'}; color: white; padding: 2px 5px; border-radius: 3px;`
                );
                if (data !== null) {
                    console.log(`%cResponse data:`, `color: ${isSuccess ? '#28a745' : '#dc3545'}`, data);
                }
                
                this.addToHistory('response', method + ' ' + url, `Status: ${status}`, data);
            },
            
            addToHistory: function(type, area, message, data) {
                if (!this.historyEnabled) return;
                
                this.history.unshift({
                    timestamp: new Date(),
                    type,
                    area,
                    message,
                    data: data ? JSON.parse(JSON.stringify(data)) : null
                });
                
                // Keep history at maximum size
                if (this.history.length > this.maxHistoryItems) {
                    this.history.pop();
                }
            },
            
            getHistory: function() {
                return this.history;
            },
            
            clearHistory: function() {
                this.history = [];
                console.log('%c[DEBUG] History cleared', 'color: #bada55');
            },
            
            showHistory: function() {
                console.group('Debug History');
                this.history.forEach((item, index) => {
                    const color = item.type === 'error' ? '#ff6347' : 
                                 item.type === 'request' ? '#0066cc' :
                                 item.type === 'response' ? '#28a745' : '#bada55';
                    
                    console.log(
                        `%c[${item.timestamp.toLocaleTimeString()}][${item.type.toUpperCase()}] ${item.area}`, 
                        `color: ${color}; font-weight: bold;`
                    );
                    if (item.message) console.log(`Message: ${item.message}`);
                    if (item.data) console.log('Data:', item.data);
                });
                console.groupEnd();
            }
        };

        let categories = [];
        let categoryToDelete = null;
        let stream = null;
        let modalMode = 'add';
        
        // DOM Elements
        const categoriesContainer = document.getElementById('categoriesContainer');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const emptyState = document.getElementById('emptyState');
        const searchInput = document.getElementById('searchInput');
        const categoryModal = new bootstrap.Modal(document.getElementById('categoryModal'));
        const deleteModal = new bootstrap.Modal(document.getElementById('deleteModal'));
        const categoryForm = document.getElementById('categoryForm');
        const categoryIdInput = document.getElementById('categoryId');
        const categoryNameInput = document.getElementById('categoryName');
        const categoryDescriptionInput = document.getElementById('categoryDescription');
        const displayOrderInput = document.getElementById('displayOrder');
        const isActiveInput = document.getElementById('isActive');
        const imagePreview = document.getElementById('imagePreview');
        const imageBase64Input = document.getElementById('imageBase64');
        const imageUpload = document.getElementById('imageUpload');
        const cameraCapture = document.getElementById('cameraCapture');
        const cameraBtns = document.getElementById('cameraBtns');
        const takePhotoBtn = document.getElementById('takePhotoBtn');
        const totalCategoriesElement = document.getElementById('totalCategories');
        const activeCategoriesElement = document.getElementById('activeCategories');
        const inactiveCategoriesElement = document.getElementById('inactiveCategories');
        const lastUpdatedElement = document.getElementById('lastUpdated');
        
        // Full Frame Modal Elements & Variables
        let fullFrameModalStream = null;
        const fullFrameCategoryModal = document.getElementById('fullFrameCategoryModal');
        const fullFrameCategoryForm = document.getElementById('fullFrameCategoryForm');
        const fullFrameCategoryTitle = document.getElementById('fullFrameCategoryTitle');
        const fullFrameCategoryId = document.getElementById('fullFrameCategoryId');
        const fullFrameCategoryName = document.getElementById('fullFrameCategoryName');
        const fullFrameCategoryDescription = document.getElementById('fullFrameCategoryDescription');
        const fullFrameDisplayOrder = document.getElementById('fullFrameDisplayOrder');
        const fullFrameIsActive = document.getElementById('fullFrameIsActive');
        const fullFrameImagePreview = document.getElementById('fullFrameImagePreview');
        const fullFrameImageBase64 = document.getElementById('fullFrameImageBase64');
        const fullFrameImageUpload = document.getElementById('fullFrameImageUpload');
        const fullFrameCameraCapture = document.getElementById('fullFrameCameraCapture');
        const fullFrameCameraBtns = document.getElementById('fullFrameCameraBtns');
        const fullFrameTakePhotoBtn = document.getElementById('fullFrameTakePhotoBtn');
        const saveFullFrameCategory = document.getElementById('saveFullFrameCategory');
        const closeFullFrameModal = document.getElementById('closeFullFrameModal');
        const cancelFullFrameModal = document.getElementById('cancelFullFrameModal');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Check authentication on page load
            checkAuthentication();
            
            fetchCategories();
            setupEventListeners();
            updateDateTime();
            
            // Add security measures
            setupSecurityMeasures();

            // Add to existing DOMContentLoaded
            setupFullFrameModalEventListeners();
        });
        
        // Setup Event Listeners
        function setupEventListeners() {
            // Category Form Submit
            categoryForm.addEventListener('submit', function(e) {
                e.preventDefault();
                saveCategory();
            });
            
            // Image Upload
            imageUpload.addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (file) {
                    // Show loading indicator
                    imagePreview.innerHTML = `
                        <div class="d-flex justify-content-center align-items-center h-100">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Uploading...</span>
                            </div>
                            <span class="ms-2">Uploading image...</span>
                        </div>
                    `;
                    
                    try {
                        // Get username from session/local storage
                        const username = sessionStorage.getItem('username') || localStorage.getItem('username') || 'admin';
                        
                        // Get Cloudinary credentials using your existing function
                        const credentials = await getCloudinaryCredentials(username);
                        
                        if (!credentials || !credentials.cloud_name || !credentials.upload_preset) {
                            throw new Error('Invalid Cloudinary credentials');
                        }
                        
                        // Use your cloudinary-operations.js to upload the file
                        const cloudinaryUrl = await uploadToCloudinary(
                            file, 
                            credentials.cloud_name, 
                            credentials.upload_preset
                        );
                        
                        // Update the preview image with the Cloudinary URL
                        updateImagePreview(cloudinaryUrl);
                        
                        // Set the hidden input value to the Cloudinary URL
                        imageBase64Input.value = cloudinaryUrl;
                        
                        // Show success message
                        showSuccess('Image uploaded successfully!');
                    } catch (error) {
                        console.error('Error uploading image:', error);
                        showError('Failed to upload image: ' + error.message);
                        
                        // Fallback to local FileReader if upload fails
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            updateImagePreview(event.target.result);
                            imageBase64Input.value = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                }
            });
            
            // Take Photo Button
            takePhotoBtn.addEventListener('click', captureImage);
            
            // Confirm Delete Button
            document.getElementById('confirmDeleteBtn').addEventListener('click', confirmDeleteCategory);
        }
        
        // Setup Event Listeners for Full Frame Modal
        function setupFullFrameModalEventListeners() {
            // Close buttons
            closeFullFrameModal.addEventListener('click', closeFullFrameCategoryModal);
            cancelFullFrameModal.addEventListener('click', closeFullFrameCategoryModal);
            
            // Save button
            saveFullFrameCategory.addEventListener('click', saveFullFrameCategoryData);
            
            // Full Frame Delete Modal Elements
            const closeFullFrameDeleteModalBtn = document.getElementById('closeFullFrameDeleteModal');
            const cancelFullFrameDeleteModalBtn = document.getElementById('cancelFullFrameDeleteModal');
            const confirmFullFrameDeleteBtn = document.getElementById('confirmFullFrameDeleteBtn');
            
            // Add delete modal event listeners
            closeFullFrameDeleteModalBtn.addEventListener('click', closeFullFrameDeleteModal);
            cancelFullFrameDeleteModalBtn.addEventListener('click', closeFullFrameDeleteModal);
            confirmFullFrameDeleteBtn.addEventListener('click', confirmFullFrameDeleteCategory);
            
            // Image Upload
            fullFrameImageUpload.addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (file) {
                    // Show loading indicator
                    fullFrameImagePreview.innerHTML = `
                        <div class="d-flex justify-content-center align-items-center h-100">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Uploading...</span>
                            </div>
                            <span class="ms-2">Uploading image...</span>
                        </div>
                    `;
                    
                    try {
                        // Get username from session/local storage
                        const username = sessionStorage.getItem('username') || localStorage.getItem('username') || 'admin';
                        
                        // Get Cloudinary credentials
                        const credentials = await getCloudinaryCredentials(username);
                        
                        if (!credentials || !credentials.cloud_name || !credentials.upload_preset) {
                            throw new Error('Invalid Cloudinary credentials');
                        }
                        
                        // Use cloudinary-operations.js to upload the file
                        const cloudinaryUrl = await uploadToCloudinary(
                            file, 
                            credentials.cloud_name, 
                            credentials.upload_preset
                        );
                        
                        // Update the preview image with the Cloudinary URL
                        updateFullFrameImagePreview(cloudinaryUrl);
                        
                        // Set the hidden input value to the Cloudinary URL
                        fullFrameImageBase64.value = cloudinaryUrl;
                        
                        // Show success message
                        showSuccess('Image uploaded successfully!');
                    } catch (error) {
                        console.error('Error uploading image:', error);
                        showError('Failed to upload image: ' + error.message);
                        
                        // Fallback to local FileReader if upload fails
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            updateFullFrameImagePreview(event.target.result);
                            fullFrameImageBase64.value = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                }
            });
            
            // Take Photo Button
            fullFrameTakePhotoBtn.addEventListener('click', captureFullFrameImage);
        }
        
        // Fetch Categories from API with better error handling and security
        async function fetchCategories() {
            showLoading(true);
            
            try {
                const authToken = sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token');
                const username = sessionStorage.getItem('username') || localStorage.getItem('username');
                
                if (!username) {
                    showError('Authentication error: Username not found');
                    return;
                }
                
                const response = await fetch('/api/menu-categories', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + authToken
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
                    console.error('API error response:', errorData);
                    
                    // Show empty state for any error
                    categories = [];
                    updateStats();
                    renderCategories();
                    
                    // Log detailed error for debugging
                    if (errorData && errorData.message && errorData.message.includes("relation")) {
                        console.error("Database table case mismatch. API is looking for 'MENU_CATEGORIES' but table is 'menu_categories'");
                    }
                    
                    return;
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // Filter categories by the logged-in user's username
                    const allCategories = data.data || [];
                    categories = allCategories.filter(category => category.USERNAME === username);
                    
                    console.log(`Filtered ${allCategories.length} categories to ${categories.length} for user ${username}`);
                    
                    updateStats();
                    renderCategories();
                } else {
                    showError(data.message || 'Failed to load categories');
                }
            } catch (error) {
                console.error('Error fetching categories:', error);
                
                // Use empty array when error occurs, to show empty state
                categories = [];
                updateStats();
                renderCategories();
                
                // Still show error toast
                showError('An error occurred while loading categories. Please try again later.');
            } finally {
                showLoading(false);
            }
        }
        
        // Render Categories to UI with enhanced layout
        function renderCategories() {
            // Clear container
            categoriesContainer.innerHTML = '';
            
            if (categories.length === 0) {
                emptyState.classList.remove('d-none');
                return;
            }
            
            emptyState.classList.add('d-none');
            
            // Sort categories by display order
            const sortedCategories = [...categories].sort((a, b) => a.DISPLAY_ORDER - b.DISPLAY_ORDER);
            
            // Create the container with proper styling
            const categoryList = document.createElement('div');
            categoryList.className = 'category-list';
            categoryList.style.padding = '10px';
            
            // Create category rows with improved image handling
            sortedCategories.forEach(category => {
                // Set default image if none provided
                const bgUrl = category.GROUP_IMGURL || 'https://via.placeholder.com/160x160?text=No+Image';
                const isActive = category.IS_ACTIVE;
                
                const categoryItem = document.createElement('div');
                categoryItem.className = 'category-item';
                categoryItem.style.position = 'relative'; // Make sure position is relative for absolute button positioning
                categoryItem.onclick = (e) => {
                    // Only call viewCategory if the click is directly on the item and not on a button
                    if (e.target === categoryItem || 
                        e.target.closest('.category-main-info') ||
                        e.target.closest('.category-image')) {
                        viewCategory(category.CATEGORY_ID);
                    }
                };
                
                categoryItem.innerHTML = `
                    <div class="category-image" style="background-image: url('${bgUrl}')"></div>
                    <div class="category-details">
                        <div class="category-main-info">
                            <h4 class="category-title">
                                <span class="category-order-compact">${category.DISPLAY_ORDER}</span>
                                ${category.NAME}
                                <span class="category-status ${isActive ? 'active' : 'inactive'}" 
                                      title="${isActive ? 'Active' : 'Inactive'}"></span>
                            </h4>
                            <p class="category-desc">${category.DESCRIPTION || 'No description'}</p>
                        </div>
                        <div class="category-actions">
                            <button class="category-action-compact action-edit-compact" 
                                    onclick="editCategory(${category.CATEGORY_ID}, event)" 
                                    title="Edit category">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="category-action-compact action-delete-compact" 
                                    onclick="deleteCategory(${category.CATEGORY_ID}, '${category.NAME.replace(/'/g, "\\'")}', event)" 
                                    title="Delete category">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
                
                // Add the category item to the list
                categoryList.appendChild(categoryItem);
            });
            
            categoriesContainer.appendChild(categoryList);
            
            // Add debug log to console for image loading
            console.log('Categories rendered with images:', 
                sortedCategories.map(c => ({
                    id: c.CATEGORY_ID,
                    name: c.NAME,
                    hasImage: !!c.GROUP_IMGURL,
                    imageSrc: c.GROUP_IMGURL || '(placeholder)'
                }))
            );
        }
        
        // Open Category Modal for Adding
        function openCategoryModal() {
            modalMode = 'add';
            
            // Update title for add mode
            fullFrameCategoryTitle.textContent = 'Add New Category';
            
            // Reset form
            resetFullFrameForm();
            
            // Configure save button for add mode
            saveFullFrameCategory.innerHTML = '<i class="fas fa-plus me-2"></i>Add Category';
            
            // Show the full-frame modal
            fullFrameCategoryModal.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent scrolling of the body
        }
        
        // View Category
        function viewCategory(id) {
            // Navigate to menu items filtered by this category
            // For now, we'll just show the edit modal
            editCategory(id);
        }
        
        // Edit Category
        function editCategory(id, event) {
            if (event) {
                event.stopPropagation(); // Stop event propagation to prevent viewCategory from being triggered
                event.preventDefault(); // Prevent default behavior
            }
            
            console.log(`Editing category with ID: ${id}`);
            
            // Find the category to edit
            const category = categories.find(c => c.CATEGORY_ID === id);
            if (!category) {
                showError('Category not found');
                return;
            }
            
            // Use the full-frame modal for editing
            modalMode = 'edit'; // Set the modal mode to edit
            openFullFrameCategoryModal(id);
        }
        
        // Delete Category (opens full-frame confirmation modal)
        function deleteCategory(id, name, event) {
            if (event) {
                event.stopPropagation(); // Stop event propagation to prevent viewCategory from being triggered
                event.preventDefault(); // Prevent default behavior
            }
            
            console.log(`Preparing to delete category with ID: ${id}, Name: ${name}`);
            
            categoryToDelete = id;
            
            // Use the full-frame delete modal instead of the bootstrap modal
            document.getElementById('fullFrameDeleteCategoryName').textContent = name;
            openFullFrameDeleteModal();
        }
        
        // Open Full Frame Delete Modal
        function openFullFrameDeleteModal() {
            const fullFrameDeleteModal = document.getElementById('fullFrameDeleteModal');
            fullFrameDeleteModal.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent scrolling of the body
        }
        
        // Close Full Frame Delete Modal
        function closeFullFrameDeleteModal() {
            const fullFrameDeleteModal = document.getElementById('fullFrameDeleteModal');
            fullFrameDeleteModal.classList.remove('show');
            document.body.style.overflow = ''; // Restore body scrolling
            categoryToDelete = null;
        }
        
        // Confirm Delete Category from Full Frame Modal
        async function confirmFullFrameDeleteCategory() {
            if (!categoryToDelete) return;
            
            const deleteBtn = document.getElementById('confirmFullFrameDeleteBtn');
            deleteBtn.disabled = true;
            deleteBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Deleting...';
            
            try {
                debugTracker.log('Delete Category', `Attempting to delete category ID: ${categoryToDelete}`, { id: categoryToDelete });
                
                // Get the current username from session/local storage
                const username = sessionStorage.getItem('username') || localStorage.getItem('username') || 'unknown_user';
                
                // Use RPC endpoint instead of REST API
                const response = await fetch(`/api/supabase-rpc`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + (sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token'))
                    },
                    body: JSON.stringify({
                        function_name: 'delete_menu_category',
                        params: {
                            p_category_id: categoryToDelete,
                            p_username: username
                        }
                    })
                });
                
                let data;
                try {
                    data = await response.json();
                    debugTracker.log('Delete Response', 'Got delete response', data);
                } catch (parseError) {
                    debugTracker.error('Delete Error', 'Could not parse JSON response', { 
                        status: response.status,
                        statusText: response.statusText
                    });
                    // If we can't parse the response but status is 200-299, consider it success
                    if (response.ok) {
                        data = { success: true };
                    } else {
                        throw new Error(`Server error (${response.status}): ${response.statusText || 'Unknown error'}`);
                    }
                }
                
                // Consider the operation successful if either the API returns success=true
                // OR if the status code is in the success range (handling both JSON and non-JSON responses)
                if (data.success || response.ok) {
                    // Remove from local array
                    categories = categories.filter(c => c.CATEGORY_ID !== categoryToDelete);
                    
                    // Update UI
                    updateStats();
                    renderCategories();
                    
                    // Show success message
                    showSuccess('Category deleted successfully');
                } else {
                    debugTracker.error('Delete Failed', 'API reported failure', data);
                    showError(data.message || data.error || 'Failed to delete category');
                }
                
                // Close the full-frame delete modal
                closeFullFrameDeleteModal();
            } catch (error) {
                debugTracker.error('Exception', 'Error deleting category', error);
                console.error('Error deleting category:', error);
                showError(error.message || 'An error occurred while deleting the category');
                
                // Close the modal anyway since the deletion might have actually succeeded
                // This is because we're seeing that the database record is being deleted despite the error
                closeFullFrameDeleteModal();
            } finally {
                deleteBtn.disabled = false;
                deleteBtn.innerHTML = '<i class="fas fa-trash me-2"></i>Delete Category';
                categoryToDelete = null;
            }
        }
        
        // Confirm Delete Category implementation
        async function confirmDeleteCategory() {
            if (!categoryToDelete) return;
            
            const deleteBtn = document.getElementById('confirmDeleteBtn');
            deleteBtn.disabled = true;
            deleteBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Deleting...';
            
            try {
                console.log(`Attempting to delete category ID: ${categoryToDelete}`);
                
                const response = await fetch(`/api/menu-categories/${categoryToDelete}`, {
                    method: 'DELETE'
                });
                
                let errorMsg = "";
                
                if (!response.ok) {
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.message || `Server error (${response.status})`;
                        console.error('Delete error response:', errorData);
                    } catch (parseError) {
                        // If JSON parsing fails, use the status text
                        errorMsg = `Server error (${response.status}): ${response.statusText}`;
                    }
                    
                    // Handle specific error cases we can identify
                    if (errorMsg.includes("relation") && errorMsg.includes("does not exist")) {
                        errorMsg = "Database configuration error. Please contact support.";
                        // Show more detailed information in the console for debugging
                        console.error("DATABASE TABLE CASE MISMATCH: The API is looking for 'MENU_CATEGORIES' but the table is likely named differently");
                    }
                    
                    throw new Error(errorMsg);
                }
                
                // Rest of your existing code...
                const data = await response.json();
                
                if (data.success) {
                    // Remove from local array
                    categories = categories.filter(c => c.CATEGORY_ID !== categoryToDelete);
                    
                    // Update UI
                    updateStats();
                    renderCategories();
                    
                    // Show success message
                    showSuccess('Category deleted successfully');
                } else {
                    showError(data.message || 'Failed to delete category');
                }
            } catch (error) {
                console.error('Error deleting category:', error);
                showError(error.message || 'An error occurred while deleting the category');
            } finally {
                deleteBtn.disabled = false;
                deleteBtn.innerHTML = '<i class="fas fa-trash me-2"></i>Delete Category';
                deleteModal.hide();
                categoryToDelete = null;
            }
        }
        
        // Save Category (both add and edit)
        async function saveCategory() {
            const saveBtn = document.getElementById('saveBtn');
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving...';
            
            try {
                // Get username from session/local storage with proper fallbacks
                const username = sessionStorage.getItem('username') || 
                                localStorage.getItem('username') || 
                                'unknown_user';
                
                const categoryData = {
                    NAME: categoryNameInput.value,
                    DESCRIPTION: categoryDescriptionInput.value,
                    DISPLAY_ORDER: parseInt(displayOrderInput.value) || 1,
                    IS_ACTIVE: isActiveInput.value === 'true',
                    GROUP_IMGURL: imageBase64Input.value || null,
                    // Add both CREATED_BY and UPDATED_BY fields with username value
                    CREATED_BY: username,
                    UPDATED_BY: username
                };
                
                let url = '/api/menu-categories';
                let method = 'POST';
                
                if (modalMode === 'edit') {
                    const categoryId = categoryIdInput.value;
                    if (!categoryId || categoryId.trim() === '') {
                        throw new Error('Category ID is missing for update operation');
                    }
                    url = `/api/menu-categories/${categoryId}`;
                    method = 'PUT';
                    // For edit mode, we only need to set UPDATED_BY
                    delete categoryData.CREATED_BY;
                }
                
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + (sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token'))
                    },
                    body: JSON.stringify(categoryData)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    if (modalMode === 'add') {
                        // Add new category to the array
                        categories.push(data.data);
                    } else {
                        // Update existing category
                        const index = categories.findIndex(c => c.CATEGORY_ID === parseInt(categoryIdInput.value));
                        if (index !== -1) {
                            categories[index] = data.data;
                        }
                    }
                    
                    // Update UI
                    updateStats();
                    renderCategories();
                    
                    // Show success message
                    showSuccess(`Category ${modalMode === 'add' ? 'added' : 'updated'} successfully`);
                    
                    // Close modal
                    categoryModal.hide();
                } else {
                    showError(data.message || `Failed to ${modalMode} category`);
                }
            } catch (error) {
                console.error(`Error ${modalMode === 'add' ? 'adding' : 'updating'} category:`, error);
                showError(`An error occurred while ${modalMode === 'add' ? 'adding' : 'updating'} the category`);
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = modalMode === 'add' 
                    ? '<i class="fas fa-plus me-2"></i>Add Category'
                    : '<i class="fas fa-save me-2"></i>Update Category';
            }
        }
        
        // Reset Form
        function resetForm() {
            categoryForm.reset();
            categoryIdInput.value = '';
            resetImagePreview();
            imageBase64Input.value = '';
            
            // Reset camera if active
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                cameraCapture.style.display = 'none';
                cameraBtns.classList.add('d-none');
            }
        }
        
        // Reset Image Preview
        function resetImagePreview() {
            imagePreview.innerHTML = `
                <div class="image-preview-placeholder">
                    <i class="fas fa-image fa-3x mb-2"></i>
                    <p>No image selected</p>
                </div>
            `;
        }
        
        // Update Image Preview
        function updateImagePreview(imageUrl) {
            imagePreview.innerHTML = `<img src="${imageUrl}" alt="Category Image">`;
        }
        
        // Activate Camera using the new full-screen camera modal
        function activateCamera() {
            // Open the full-screen camera modal with 'modal' target
            // This indicates we're updating the regular modal form's image
            openFullScreenCamera('modal');
        }

        // Activate Camera for Full Frame
        function activateFullFrameCamera() {
            // Open the full-screen camera modal with 'fullframe' target
            // This indicates we're updating the full-frame modal's image
            openFullScreenCamera('fullframe');
        }
        
        // Capture Image
        async function captureImage() {
            if (!stream) return;
            
            try {
                const result = await captureAndUploadImage(
                    document.getElementById('cameraCapture'),
                    document.getElementById('imagePreview'),
                    document.getElementById('imageBase64')
                );
                
                if (result.success) {
                    // Show success message
                    showSuccess(result.message);
                } else {
                    // Show error message
                    showError(result.message);
                    
                    // Fallback to local image if Cloudinary upload fails
                    const canvas = document.createElement('canvas');
                    canvas.width = document.getElementById('cameraCapture').videoWidth;
                    canvas.height = document.getElementById('cameraCapture').videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(document.getElementById('cameraCapture'), 0, 0, canvas.width, canvas.height);
                    const imageDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                    
                    // Update preview with local image
                    updateImagePreview(imageDataUrl);
                    document.getElementById('imageBase64').value = imageDataUrl;
                }
            } catch (error) {
                console.error('Error capturing image:', error);
                showError('Failed to capture image: ' + error.message);
            } finally {
                // Stop camera stream
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                    cameraCapture.style.display = 'none';
                    cameraBtns.classList.add('d-none');
                }
            }
        }
        
        // Update Statistics
        function updateStats() {
            const total = categories.length;
            const active = categories.filter(c => c.IS_ACTIVE).length;
            const inactive = total - active;
            
            totalCategoriesElement.textContent = total;
            activeCategoriesElement.textContent = active;
            inactiveCategoriesElement.textContent = inactive;
        }
        
        // Update Date/Time
        function updateDateTime() {
            const now = new Date();
            const options = { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            lastUpdatedElement.textContent = now.toLocaleDateString('en-US', options);
        }
        
        // Show Loading
        function showLoading(show) {
            if (show) {
                loadingSpinner.classList.remove('d-none');
                categoriesContainer.classList.add('d-none');
            } else {
                loadingSpinner.classList.add('d-none');
                categoriesContainer.classList.remove('d-none');
            }
        }
        
        // Replace the placeholder showError and showSuccess functions
        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            const toastIcon = document.getElementById('toastIcon');
            const toastMessage = document.getElementById('toastMessage');
            
            // Reset previous classes
            toast.classList.remove('bg-danger', 'bg-success');
            
            if (isError) {
                toast.classList.add('bg-danger', 'text-white');
                toastIcon.className = 'fas fa-exclamation-circle';
            } else {
                toast.classList.add('bg-success', 'text-white');
                toastIcon.className = 'fas fa-check-circle';
            }
            
            toastMessage.textContent = message;
            
            // Initialize Bootstrap toast with short duration
            const bsToast = new bootstrap.Toast(toast, {
                delay: 2000 // Show for 2 seconds only
            });
            bsToast.show();
        }

        function showError(message) {
            showToast(message, true);
        }

        function showSuccess(message) {
            showToast(message, false);
        }
        
        // Go Back Function
        function goBack() {
            if (document.referrer) {
                window.location.href = document.referrer;
            } else {
                window.location.href = '../index.html';
            }
        }
        
        // Add this helper function to get Cloudinary credentials
        async function getCloudinaryCredentials(username) {
            try {
                const response = await fetch('/api/cloudinary-credentials');
                if (!response.ok) {
                    throw new Error(`Failed to fetch Cloudinary credentials: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Error getting Cloudinary credentials:', error);
                throw error;
            }
        }

        // Check if user is authenticated
        function checkAuthentication() {
            const token = sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token');
            const username = sessionStorage.getItem('username') || localStorage.getItem('username');
            
            if (!token || !username) {
                // Redirect to login if not authenticated
                window.location.href = '../login.html';
                return false;
            }
            
            return true;
        }
        
        // Setup security measures
        function setupSecurityMeasures() {
            // Hide source code content from dev tools
            setInterval(function() {
                // This makes it harder to view source in browser
                const devtools = /./;
                devtools.toString = function() {
                    checkAuthentication();
                    return '';
                }
                
                // Removed console.clear() to allow viewing console messages
            }, 3000);
            
            // Disable right-click
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                return false;
            });
            
            // Add listener for devtools opening using firebug technique
            window.addEventListener('devtoolschange', function(e) {
                if (e.detail.open) {
                    // Reload page when devtools opens
                    window.location.reload();
                }
            });
        }

        // Upload to Cloudinary function
        async function uploadToCloudinary(blob, cloudName, uploadPreset) {
            console.log("Uploading to Cloudinary with cloud_name:", cloudName);
            console.log("Using upload_preset:", uploadPreset);
            
            if (!blob || !cloudName || !uploadPreset) {
                throw new Error("Missing required parameters for Cloudinary upload");
            }
            
            const formData = new FormData();
            formData.append('file', blob);
            formData.append('upload_preset', uploadPreset);
            
            try {
                // Fetch from the direct Cloudinary upload endpoint
                const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Cloudinary upload error:', errorData);
                    throw new Error(`Cloudinary upload failed: ${errorData.error?.message || response.statusText}`);
                }
                
                const data = await response.json();
                console.log("Cloudinary upload success:", data);
                
                // Return the secure URL of the uploaded image
                return data.secure_url;
            } catch (error) {
                console.error('Error in uploadToCloudinary:', error);
                throw new Error(`Cloudinary upload error: ${error.message}`);
            }
        }
        
        // Open Full Frame Category Edit Modal
        function openFullFrameCategoryModal(id) {
            const category = categories.find(c => c.CATEGORY_ID === id);
            
            if (!category) {
                showError('Category not found');
                return;
            }
            
            // Update title
            fullFrameCategoryTitle.textContent = `Edit Category: ${category.NAME}`;
            
            // Set form values
            fullFrameCategoryId.value = category.CATEGORY_ID;
            fullFrameCategoryName.value = category.NAME || '';
            fullFrameCategoryDescription.value = category.DESCRIPTION || '';
            fullFrameDisplayOrder.value = category.DISPLAY_ORDER || 1;
            fullFrameIsActive.value = category.IS_ACTIVE ? 'true' : 'false';
            
            // Set image if available
            if (category.GROUP_IMGURL) {
                updateFullFrameImagePreview(category.GROUP_IMGURL);
                fullFrameImageBase64.value = category.GROUP_IMGURL;
            } else {
                // Reset image preview
                resetFullFrameImagePreview();
            }
            
            // Update the save button text for edit mode
            saveFullFrameCategory.innerHTML = '<i class="fas fa-save me-2"></i>Save Changes';
            
            // Show the modal
            fullFrameCategoryModal.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent scrolling of the body
        }
        
        // Close Full Frame Modal
        function closeFullFrameCategoryModal() {
            fullFrameCategoryModal.classList.remove('show');
            document.body.style.overflow = ''; // Restore body scrolling
            
            // Reset form and camera if active
            resetFullFrameForm();
        }
        
        // Reset Full Frame Form
        function resetFullFrameForm() {
            fullFrameCategoryForm.reset();
            fullFrameCategoryId.value = '';
            resetFullFrameImagePreview();
            fullFrameImageBase64.value = '';
            
            // Reset camera if active
            if (fullFrameModalStream) {
                fullFrameModalStream.getTracks().forEach(track => track.stop());
                fullFrameModalStream = null;
                fullFrameCameraCapture.style.display = 'none';
                fullFrameCameraBtns.classList.add('d-none');
            }
        }
        
        // Reset Full Frame Image Preview
        function resetFullFrameImagePreview() {
            fullFrameImagePreview.innerHTML = `
                <div class="image-preview-placeholder">
                    <i class="fas fa-image fa-3x mb-2"></i>
                    <p>No image selected</p>
                </div>
            `;
        }
        
        // Update Full Frame Image Preview
        function updateFullFrameImagePreview(imageUrl) {
            fullFrameImagePreview.innerHTML = `<img src="${imageUrl}" alt="Category Image">`;
        }
        
        // Activate Full Frame Camera
        function activateFullFrameCamera() {
            if (fullFrameModalStream) {
                // Stop existing stream
                fullFrameModalStream.getTracks().forEach(track => track.stop());
                fullFrameModalStream = null;
                fullFrameCameraCapture.style.display = 'none';
                fullFrameCameraBtns.classList.add('d-none');
                return;
            }
            
            // Show camera UI
            fullFrameCameraCapture.style.display = 'block';
            fullFrameCameraBtns.classList.remove('d-none');
            
            // Access the device camera
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'environment' // Prefer rear camera on mobile devices
                }, 
                audio: false 
            })
            .then(function(mediaStream) {
                fullFrameModalStream = mediaStream;
                fullFrameCameraCapture.srcObject = mediaStream;
                fullFrameCameraCapture.play();
            })
            .catch(function(err) {
                console.error('Error accessing camera:', err);
                showError('Unable to access camera: ' + err.message);
                
                fullFrameCameraCapture.style.display = 'none';
                fullFrameCameraBtns.classList.add('d-none');
            });
        }
        
        // Capture Image in Full Frame Modal
        async function captureFullFrameImage() {
            if (!fullFrameModalStream) return;
            
            try {
                // First get the Cloudinary credentials to ensure they're available
                const username = sessionStorage.getItem('username') || localStorage.getItem('username') || 'admin';
                console.log('Preparing to capture image for user:', username);
                
                // Create a canvas element to capture the current video frame
                const canvas = document.createElement('canvas');
                canvas.width = fullFrameCameraCapture.videoWidth;
                canvas.height = fullFrameCameraCapture.videoHeight;
                
                // Draw the current video frame to the canvas
                const ctx = canvas.getContext('2d');
                ctx.drawImage(fullFrameCameraCapture, 0, 0, canvas.width, canvas.height);
                
                // Convert the canvas to a data URL (base64 encoded image)
                const imageDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                
                // Show loading indicator in the preview area
                fullFrameImagePreview.innerHTML = `
                    <div class="d-flex justify-content-center align-items-center h-100">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Uploading...</span>
                        </div>
                        <span class="ms-2">Uploading image...</span>
                    </div>
                `;
                
                // Convert base64 to blob
                const blob = await fetch(imageDataUrl).then(res => res.blob());
                
                try {
                    // Get Cloudinary credentials first to ensure we have them
                    const credentials = await getCloudinaryCredentials(username);
                    console.log('Got Cloudinary credentials:', credentials.cloud_name);
                    
                    if (!credentials || !credentials.cloud_name || !credentials.upload_preset) {
                        throw new Error('Invalid Cloudinary credentials');
                    }
                    
                    // Explicitly call uploadToCloudinary with all required parameters
                    const cloudinaryUrl = await uploadToCloudinary(
                        blob,
                        credentials.cloud_name,
                        credentials.upload_preset
                    );
                    
                    // Update the preview element with the uploaded image
                    fullFrameImagePreview.innerHTML = `<img src="${cloudinaryUrl}" alt="Uploaded Image">`;
                    
                    // Set the hidden input value to the Cloudinary URL
                    fullFrameImageBase64.value = cloudinaryUrl;
                    
                    showSuccess('Image uploaded successfully to Cloudinary!');
                } catch (cloudinaryError) {
                    console.error('Cloudinary upload failed:', cloudinaryError);
                    
                    // Fallback to using the local base64 image
                    console.log('Falling back to local image');
                    fullFrameImagePreview.innerHTML = `<img src="${imageDataUrl}" alt="Local Image">`;
                    fullFrameImageBase64.value = imageDataUrl;
                    
                    showError('Cloudinary upload failed, using local image instead.');
                }
            } catch (error) {
                console.error('Error capturing image:', error);
                showError('Failed to capture image: ' + error.message);
            } finally {
                // Stop camera stream
                if (fullFrameModalStream) {
                    fullFrameModalStream.getTracks().forEach(track => track.stop());
                    fullFrameModalStream = null;
                    fullFrameCameraCapture.style.display = 'none';
                    fullFrameCameraBtns.classList.add('d-none');
                }
            }
        }
        
        // Save Category from Full Frame Modal
        async function saveFullFrameCategoryData() {
            saveFullFrameCategory.disabled = true;
            saveFullFrameCategory.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving...';
            
            try {
                // Get username from session/local storage with proper fallbacks
                const username = sessionStorage.getItem('username') || 
                                localStorage.getItem('username') || 
                                'unknown_user';
                
                const categoryData = {
                    NAME: fullFrameCategoryName.value,
                    DESCRIPTION: fullFrameCategoryDescription.value,
                    DISPLAY_ORDER: parseInt(fullFrameDisplayOrder.value) || 1,
                    IS_ACTIVE: fullFrameIsActive.value === 'true',
                    GROUP_IMGURL: fullFrameImageBase64.value || null,
                    USERNAME: username,
                    UPDATED_BY: username
                };
                
                debugTracker.log('Category Save', 'Preparing to save category data', categoryData);
                
                let isEdit = false;
                let response;
                
                // Check if we're in edit mode by looking at the hidden category ID field
                if (fullFrameCategoryId.value && fullFrameCategoryId.value.trim() !== '') {
                    isEdit = true;
                    const categoryId = parseInt(fullFrameCategoryId.value);
                    
                    // Use RPC endpoint for update operation
                    debugTracker.log('Edit Category', `Using RPC to update category with ID: ${categoryId}`, {
                        categoryId,
                        categoryName: fullFrameCategoryName.value
                    });
                    
                    // Call the update_menu_category RPC function
                    response = await fetch(`/api/supabase-rpc`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + (sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token'))
                        },
                        body: JSON.stringify({
                            function_name: 'update_menu_category',
                            params: {
                                p_category_id: categoryId,
                                p_name: categoryData.NAME,
                                p_description: categoryData.DESCRIPTION,
                                p_display_order: categoryData.DISPLAY_ORDER,
                                p_is_active: categoryData.IS_ACTIVE,
                                p_group_imgurl: categoryData.GROUP_IMGURL,
                                p_username: username,
                                p_updated_by: username
                            }
                        })
                    });
                    
                    debugTracker.request('POST', '/api/supabase-rpc (update_menu_category)', {
                        function_name: 'update_menu_category',
                        params: {
                            p_category_id: categoryId,
                            p_name: categoryData.NAME,
                            p_description: categoryData.DESCRIPTION,
                            p_display_order: categoryData.DISPLAY_ORDER,
                            p_is_active: categoryData.IS_ACTIVE,
                            p_username: username
                        }
                    });
                } else {
                    // For new categories, we'll continue using the REST API
                    // Alternatively, you could create an RPC function for this too
                    categoryData.CREATED_BY = username;
                    
                    debugTracker.log('Add Category', 'Creating new category via REST API', {
                        categoryName: fullFrameCategoryName.value
                    });
                    
                    response = await fetch('/api/menu-categories', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + (sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token'))
                        },
                        body: JSON.stringify(categoryData)
                    });
                    
                    debugTracker.request('POST', '/api/menu-categories', categoryData);
                }
                
                let responseData;
                try {
                    responseData = await response.json();
                    debugTracker.response(isEdit ? 'RPC' : 'POST', 
                                        isEdit ? '/api/supabase-rpc' : '/api/menu-categories', 
                                        response.status, 
                                        responseData);
                } catch (parseError) {
                    debugTracker.error('API Response', 'Failed to parse JSON response', parseError);
                    throw new Error('Invalid response from server');
                }
                
                if (!response.ok) {
                    const errorMsg = responseData.message || responseData.error || `Server error (${response.status})`;
                    throw new Error(errorMsg);
                }
                
                if (responseData.success || (isEdit && responseData.data)) {
                    if (isEdit) {
                        // Get the updated category data
                        const updatedCategory = responseData.data || {
                            CATEGORY_ID: parseInt(fullFrameCategoryId.value),
                            ...categoryData,
                            UPDATED_AT: new Date().toISOString()
                        };
                        
                        // Update existing category in the array
                        const index = categories.findIndex(c => c.CATEGORY_ID === parseInt(fullFrameCategoryId.value));
                        if (index !== -1) {
                            categories[index] = {
                                ...categories[index],
                                ...updatedCategory
                            };
                        }
                    } else {
                        // Add new category to the array
                        categories.push(responseData.data);
                    }
                    
                    // Update UI
                    updateStats();
                    renderCategories();
                    updateDateTime();
                    
                    // Show success message
                    showSuccess(`Category ${isEdit ? 'updated' : 'added'} successfully`);
                    
                    // Close modal
                    closeFullFrameCategoryModal();
                } else {
                    showError(responseData.message || responseData.error || `Failed to ${isEdit ? 'update' : 'add'} category`);
                }
            } catch (error) {
                debugTracker.error('Category Save', error.message, error);
                console.error(`Error saving category:`, error);
                showError(`An error occurred while saving the category: ${error.message}`);
            } finally {
                saveFullFrameCategory.disabled = false;
                saveFullFrameCategory.innerHTML = fullFrameCategoryId.value ? '<i class="fas fa-save me-2"></i>Update Category' : '<i class="fas fa-plus me-2"></i>Add Category';
            }
        }
        
        // Full frame modal functions for categories
        function openFullFrameCategoryModal(id = null) {
            // Reset form first
            resetFullFrameForm();
            
            // Set modal title and button text based on mode
            if (id) {
                fullFrameCategoryTitle.textContent = 'Edit Category';
                saveFullFrameCategory.innerHTML = '<i class="fas fa-save me-2"></i>Update Category';
                
                // Find category by ID
                const category = categories.find(c => c.CATEGORY_ID === id);
                if (!category) {
                    showError('Category not found');
                    return;
                }
                
                // Populate form fields
                fullFrameCategoryId.value = category.CATEGORY_ID;
                fullFrameCategoryName.value = category.NAME;
                fullFrameCategoryDescription.value = category.DESCRIPTION || '';
                fullFrameDisplayOrder.value = category.DISPLAY_ORDER || 1;
                fullFrameIsActive.value = category.IS_ACTIVE ? 'true' : 'false';
                
                // Set image if available
                if (category.GROUP_IMGURL) {
                    updateFullFrameImagePreview(category.GROUP_IMGURL);
                    fullFrameImageBase64.value = category.GROUP_IMGURL;
                }
            } else {
                fullFrameCategoryTitle.textContent = 'Add New Category';
                saveFullFrameCategory.innerHTML = '<i class="fas fa-plus me-2"></i>Add Category';
            }
            
            // Show the full-frame modal
            fullFrameCategoryModal.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent scrolling of the body
        }

        // Close the full frame category modal
        function closeFullFrameCategoryModal() {
            // Stop camera if active
            stopFullFrameCamera();
            
            // Hide modal
            fullFrameCategoryModal.classList.remove('show');
            document.body.style.overflow = ''; // Restore body scrolling
        }

        // Reset full frame category form
        function resetFullFrameForm() {
            fullFrameCategoryForm.reset();
            fullFrameCategoryId.value = '';
            resetFullFrameImagePreview();
            fullFrameImageBase64.value = '';
            
            // Stop camera if active
            stopFullFrameCamera();
        }

        // Reset full frame image preview
        function resetFullFrameImagePreview() {
            fullFrameImagePreview.innerHTML = `
                <div class="image-preview-placeholder">
                    <i class="fas fa-image fa-3x mb-2"></i>
                    <p>No image selected</p>
                </div>
            `;
        }

        // Update full frame image preview
        function updateFullFrameImagePreview(imageUrl) {
            fullFrameImagePreview.innerHTML = `<img src="${imageUrl}" alt="Category Image" style="width: 100%; height: 100%; object-fit: contain;">`;
        }

        // Activate camera for full frame modal
        function activateFullFrameCamera() {
            // First, stop any existing camera stream
            stopFullFrameCamera();
            
            // Check if camera-modal.js functions are available
            if (typeof openCameraModal === 'function') {
                // Use the shared camera modal component
                openCameraModal('fullFrameCategoryForm', 'fullFrameImagePreview', 'fullFrameImageBase64');
                return;
            }
            
            // Fallback to manual camera implementation if camera-modal.js is not available
            fullFrameCameraCapture.style.display = 'block';
            fullFrameCameraBtns.classList.remove('d-none');
            
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'environment' 
                }, 
                audio: false 
            })
            .then(function(mediaStream) {
                fullFrameModalStream = mediaStream;
                fullFrameCameraCapture.srcObject = mediaStream;
                fullFrameCameraCapture.play();
            })
            .catch(function(err) {
                console.error('Error accessing camera:', err);
                showError('Unable to access camera: ' + err.message);
                stopFullFrameCamera();
            });
        }

        // Stop camera for full frame modal
        function stopFullFrameCamera() {
            // Stop camera stream if active
            if (fullFrameModalStream) {
                fullFrameModalStream.getTracks().forEach(track => track.stop());
                fullFrameModalStream = null;
                fullFrameCameraCapture.style.display = 'none';
                fullFrameCameraBtns.classList.add('d-none');
            }
        }

        // Capture image for full frame modal
        async function captureFullFrameImage() {
            if (!fullFrameModalStream) return;
            
            try {
                // Create canvas for capturing
                const canvas = document.createElement('canvas');
                canvas.width = fullFrameCameraCapture.videoWidth;
                canvas.height = fullFrameCameraCapture.videoHeight;
                
                // Draw video frame to canvas
                const ctx = canvas.getContext('2d');
                ctx.drawImage(fullFrameCameraCapture, 0, 0, canvas.width, canvas.height);
                
                // Convert to data URL
                const imageDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                
                // Try to upload to Cloudinary if available
                try {
                    // Get username from session/local storage
                    const username = sessionStorage.getItem('username') || localStorage.getItem('username') || 'admin';
                    
                    // Get Cloudinary credentials
                    const credentials = await getCloudinaryCredentials(username);
                    
                    if (!credentials || !credentials.cloud_name || !credentials.upload_preset) {
                        throw new Error('Invalid Cloudinary credentials');
                    }
                    
                    // Convert data URL to blob for upload
                    function dataURLtoBlob(dataUrl) {
                        const arr = dataUrl.split(',');
                        const mime = arr[0].match(/:(.*?);/)[1];
                        const bstr = atob(arr[1]);
                        let n = bstr.length;
                        const u8arr = new Uint8Array(n);
                        while (n--) {
                            u8arr[n] = bstr.charCodeAt(n);
                        }
                        return new Blob([u8arr], { type: mime });
                    }
                    const blob = dataURLtoBlob(imageDataUrl);
                    
                    // Upload to Cloudinary
                    const cloudinaryUrl = await uploadToCloudinary(
                        blob, 
                        credentials.cloud_name, 
                        credentials.upload_preset
                    );
                    
                    // Update the preview element with the Cloudinary URL
                    updateFullFrameImagePreview(cloudinaryUrl);
                    fullFrameImageBase64.value = cloudinaryUrl;
                    
                    // Show success message
                    showSuccess('Image uploaded successfully!');
                } catch (uploadError) {
                    console.error('Error uploading to Cloudinary:', uploadError);
                    
                    // Fallback to local image
                    updateFullFrameImagePreview(imageDataUrl);
                    fullFrameImageBase64.value = imageDataUrl;
                    
                    // Show warning toast
                    if (typeof showToast === 'function') {
                        showToast('Using local image instead of cloud storage', false);
                    }
                }
            } catch (error) {
                console.error('Error capturing image:', error);
                showError('Failed to capture image: ' + error.message);
            } finally {
                // Stop camera after capturing
                stopFullFrameCamera();
            }
        }

        // Save full frame category data
        async function saveFullFrameCategoryData() {
            const saveBtn = document.getElementById('saveFullFrameCategory');
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving...';
            
            try {
                // Get username from session/local storage with proper fallbacks
                const username = sessionStorage.getItem('username') || 
                                localStorage.getItem('username') || 
                                'unknown_user';
                
                const categoryData = {
                    NAME: fullFrameCategoryName.value,
                    DESCRIPTION: fullFrameCategoryDescription.value,
                    DISPLAY_ORDER: parseInt(fullFrameDisplayOrder.value) || 1,
                    IS_ACTIVE: fullFrameIsActive.value === 'true',
                    GROUP_IMGURL: fullFrameImageBase64.value || null,
                    USERNAME: username, // Add username to ensure user-specific records
                    // Add both CREATED_BY and UPDATED_BY fields with username value
                    CREATED_BY: username,
                    UPDATED_BY: username
                };
                
                debugTracker.log('Category Save', 'Preparing to save category data', categoryData);
                
                let isEdit = false;
                let response;
                
                // Check if we're in edit mode by looking at the hidden category ID field
                if (fullFrameCategoryId.value && fullFrameCategoryId.value.trim() !== '') {
                    isEdit = true;
                    const categoryId = parseInt(fullFrameCategoryId.value);
                    
                    // Use RPC endpoint for update operation
                    debugTracker.log('Edit Category', `Using RPC to update category with ID: ${categoryId}`, {
                        categoryId,
                        categoryName: fullFrameCategoryName.value
                    });
                    
                    // Call the update_menu_category RPC function
                    response = await fetch(`/api/supabase-rpc`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + (sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token'))
                        },
                        body: JSON.stringify({
                            function_name: 'update_menu_category',
                            params: {
                                p_category_id: categoryId,
                                p_name: categoryData.NAME,
                                p_description: categoryData.DESCRIPTION,
                                p_display_order: categoryData.DISPLAY_ORDER,
                                p_is_active: categoryData.IS_ACTIVE,
                                p_group_imgurl: categoryData.GROUP_IMGURL,
                                p_username: username,
                                p_updated_by: username
                            }
                        })
                    });
                    
                    debugTracker.request('POST', '/api/supabase-rpc (update_menu_category)', {
                        function_name: 'update_menu_category',
                        params: {
                            p_category_id: categoryId,
                            p_name: categoryData.NAME,
                            p_description: categoryData.DESCRIPTION,
                            p_display_order: categoryData.DISPLAY_ORDER,
                            p_is_active: categoryData.IS_ACTIVE,
                            p_username: username
                        }
                    });
                } else {
                    // For new categories, we'll continue using the REST API
                    // Alternatively, you could create an RPC function for this too
                    categoryData.CREATED_BY = username;
                    
                    debugTracker.log('Add Category', 'Creating new category via REST API', {
                        categoryName: fullFrameCategoryName.value
                    });
                    
                    response = await fetch('/api/menu-categories', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + (sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token'))
                        },
                        body: JSON.stringify(categoryData)
                    });
                    
                    debugTracker.request('POST', '/api/menu-categories', categoryData);
                }
                
                let responseData;
                try {
                    responseData = await response.json();
                    debugTracker.response(isEdit ? 'RPC' : 'POST', 
                                        isEdit ? '/api/supabase-rpc' : '/api/menu-categories', 
                                        response.status, 
                                        responseData);
                } catch (parseError) {
                    debugTracker.error('API Response', 'Failed to parse JSON response', parseError);
                    throw new Error('Invalid response from server');
                }
                
                if (!response.ok) {
                    const errorMsg = responseData.message || responseData.error || `Server error (${response.status})`;
                    throw new Error(errorMsg);
                }
                
                if (responseData.success || (isEdit && responseData.data)) {
                    if (isEdit) {
                        // Get the updated category data
                        const updatedCategory = responseData.data || {
                            CATEGORY_ID: parseInt(fullFrameCategoryId.value),
                            ...categoryData,
                            UPDATED_AT: new Date().toISOString()
                        };
                        
                        // Update existing category in the array
                        const index = categories.findIndex(c => c.CATEGORY_ID === parseInt(fullFrameCategoryId.value));
                        if (index !== -1) {
                            categories[index] = {
                                ...categories[index],
                                ...updatedCategory
                            };
                        }
                    } else {
                        // Add new category to the array
                        categories.push(responseData.data);
                    }
                    
                    // Update UI
                    updateStats();
                    renderCategories();
                    updateDateTime();
                    
                    // Show success message
                    showSuccess(`Category ${isEdit ? 'updated' : 'added'} successfully`);
                    
                    // Close modal
                    closeFullFrameCategoryModal();
                } else {
                    showError(responseData.message || responseData.error || `Failed to ${isEdit ? 'update' : 'add'} category`);
                }
            } catch (error) {
                debugTracker.error('Category Save', error.message, error);
                console.error(`Error saving category:`, error);
                showError(`An error occurred while saving the category: ${error.message}`);
            } finally {
                saveFullFrameCategory.disabled = false;
                saveFullFrameCategory.innerHTML = fullFrameCategoryId.value ? '<i class="fas fa-save me-2"></i>Update Category' : '<i class="fas fa-plus me-2"></i>Add Category';
            }
        }

        // Generic function to show toast messages (tiny version)
        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            const toastIcon = document.getElementById('toastIcon');
            const toastMessage = document.getElementById('toastMessage');
            
            // Reset previous classes
            toast.classList.remove('bg-danger', 'bg-success');
            
            if (isError) {
                toast.classList.add('bg-danger', 'text-white');
                toastIcon.className = 'fas fa-exclamation-circle';
            } else {
                toast.classList.add('bg-success', 'text-white');
                toastIcon.className = 'fas fa-check-circle';
            }
            
            toastMessage.textContent = message;
            
            // Initialize Bootstrap toast with short duration
            const bsToast = new bootstrap.Toast(toast, {
                delay: 2000 // Show for 2 seconds only
            });
            bsToast.show();
        }

        // Show success message
        function showSuccess(message) {
            showToast(message, false);
        }

        // Show error message
        function showError(message) {
            showToast(message, true);
        }

        // Check user authentication status
        function checkAuthentication() {
            // Check for auth token and username in storage
            const authToken = sessionStorage.getItem('auth_token') || localStorage.getItem('auth_token');
            const username = sessionStorage.getItem('username') || localStorage.getItem('username');
            
            if (!authToken || !username) {
                // Redirect to login if not authenticated
                window.location.href = '/login.html';
                return false;
            }
            
            return true;
        }

        // Setup security measures
        function setupSecurityMeasures() {
            // Add custom HTTP headers for security
            document.addEventListener('DOMContentLoaded', function() {
                // Set Content Security Policy
                const meta = document.createElement('meta');
                meta.httpEquiv = 'Content-Security-Policy';
                meta.content = "default-src 'self' https://*.cloudinary.com; script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline'; style-src 'self' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com 'unsafe-inline'; img-src * data: blob:; font-src 'self' https://cdnjs.cloudflare.com; connect-src 'self' https://*.cloudinary.com https://*.supabase.co";
                document.head.appendChild(meta);
                
                // Set X-Frame-Options header via JS (for embedding purposes)
                if (window.top !== window.self) {
                    // Check if embedded in allowed domains
                    const allowedParents = ['foodbao.app', 'admin.foodbao.app'];
                    try {
                        const parentHost = window.parent.location.hostname;
                        if (!allowedParents.includes(parentHost)) {
                            window.top.location = window.self.location;
                        }
                    } catch (e) {
                        // If we can't access parent due to CORS, redirect to break out of frame
                        window.top.location = window.self.location;
                    }
                }
            });
        }
    </script>

    <!-- Full-screen Camera Modal (New implementation based on client-profile) -->
    <div id="fullScreenCameraModal" class="fullscreen-camera-overlay">
        <div class="camera-header">
            <h5 style="color: white; margin: 0;">Take Photo</h5>
            <button type="button" class="close-camera-btn" id="closeFullScreenCamera">
                <i class="material-icons">close</i>
            </button>
        </div>
        <video id="fullScreenCameraView" class="fullscreen-camera" autoplay playsinline></video>
        <div id="cameraControlsContainer" class="camera-controls">
            <button type="button" id="cameraSwitchBtn" class="flip-camera-btn">
                <i class="material-icons">flip_camera_android</i>
            </button>
            <button type="button" id="fullScreenCaptureBtn" class="capture-btn">
                <i class="material-icons" style="font-size: 24px; color: #26a69a;">camera</i>
            </button>
        </div>
        
        <!-- Hidden canvas for capturing images -->
        <canvas id="fullScreenCaptureCanvas" style="display: none;"></canvas>
    </div>

    <!-- Replace the CDN Materialize JS script with local version -->
    <!-- Load Materialize JS -->
    <script src="../js/vendor/materialize.min.js"></script>

    <!-- Add Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <script>
        // Full Screen Camera Variables
        let fullScreenCameraStream = null;
        let cameraFacingMode = 'environment'; // Default to rear camera
        let currentImageTarget = null; // To track which image is being updated (modal or full frame)
        let isUploading = false; // Flag to track if upload is in progress
        
        // Initialize the full screen camera modal
        document.addEventListener('DOMContentLoaded', function() {
            setupFullScreenCameraEventListeners();
        });

        // Set up event listeners for full screen camera
        function setupFullScreenCameraEventListeners() {
            // Close button
            const closeBtn = document.getElementById('closeFullScreenCamera');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeFullScreenCameraModal);
            }
            
            // Capture button
            const captureBtn = document.getElementById('fullScreenCaptureBtn');
            if (captureBtn) {
                captureBtn.addEventListener('click', captureFullScreenImage);
            }
            
            // Camera switch button
            const switchBtn = document.getElementById('cameraSwitchBtn');
            if (switchBtn) {
                switchBtn.addEventListener('click', switchCamera);
            }
        }

        // Open Full-Screen Camera Modal
        function openFullScreenCamera(imageTarget) {
            // Store which image we're updating (modal or full frame)
            currentImageTarget = imageTarget;
            
            // Show the camera modal
            document.getElementById('fullScreenCameraModal').style.display = 'block';
            document.body.style.overflow = 'hidden'; // Prevent scrolling
            
            // Start camera with environment (rear) camera by default
            startFullScreenCamera();
        }

        // Close Full-Screen Camera Modal
        function closeFullScreenCameraModal() {
            // Stop camera stream if active
            if (fullScreenCameraStream) {
                fullScreenCameraStream.getTracks().forEach(track => {
                    try {
                        track.stop();
                    } catch (e) {
                        console.error('Error stopping camera track:', e);
                    }
                });
                fullScreenCameraStream = null;
            }
            
            // Clear video source
            const videoElement = document.getElementById('fullScreenCameraView');
            if (videoElement) {
                videoElement.srcObject = null;
            }
            
            // Hide the modal
            document.getElementById('fullScreenCameraModal').style.display = 'none';
            document.body.style.overflow = ''; // Restore scrolling
            
            // Reset target
            currentImageTarget = null;
        }

        // Start Full-Screen Camera
        function startFullScreenCamera() {
            // Stop any existing stream
            if (fullScreenCameraStream) {
                fullScreenCameraStream.getTracks().forEach(track => {
                    try {
                        track.stop();
                    } catch (e) {
                        console.error('Error stopping camera track:', e);
                    }
                });
                fullScreenCameraStream = null;
            }
            
            // Access device camera
            navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: cameraFacingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            })
            .then(function(mediaStream) {
                // Make sure modal is still open before setting stream
                if (document.getElementById('fullScreenCameraModal').style.display !== 'block') {
                    // Modal was closed during camera initialization
                    mediaStream.getTracks().forEach(track => track.stop());
                    return;
                }
                
                fullScreenCameraStream = mediaStream;
                const videoElement = document.getElementById('fullScreenCameraView');
                videoElement.srcObject = mediaStream;
                videoElement.play()
                    .catch(err => {
                        console.error('Error playing video stream:', err);
                        showToast('Error starting camera: ' + err.message, true);
                    });
            })
            .catch(function(err) {
                console.error('Error accessing camera:', err);
                showToast('Unable to access camera: ' + err.message, true);
                closeFullScreenCameraModal();
            });
        }

        // Switch between front and rear cameras
        function switchCamera() {
            // Toggle the facingMode
            cameraFacingMode = cameraFacingMode === 'environment' ? 'user' : 'environment';
            
            // Update button icon
            document.getElementById('cameraSwitchBtn').innerHTML = 
                `<i class="material-icons">${cameraFacingMode === 'user' ? 'camera_rear' : 'camera_front'}</i>`;
            
            // Restart camera with new facing mode
            startFullScreenCamera();
        }

        // Capture Image from Full-Screen Camera
        async function captureFullScreenImage() {
            if (!fullScreenCameraStream || !currentImageTarget) {
                showToast('Camera is not ready or target not specified', true);
                return;
            }
            
            // Store the target locally so it doesn't get lost when we close the camera
            const imageTarget = currentImageTarget;
            
            try {
                // Show capturing toast
                showToast('Capturing image...', false);
                
                // Set canvas dimensions to match video
                const canvas = document.getElementById('fullScreenCaptureCanvas');
                const videoElement = document.getElementById('fullScreenCameraView');
                
                if (!videoElement.videoWidth) {
                    showToast('Camera not ready yet. Please try again.', true);
                    return;
                }
                
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                
                // Draw the current video frame to the canvas
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous content
                
                // If using front camera, flip horizontally
                if (cameraFacingMode === 'user') {
                    ctx.translate(canvas.width, 0);
                    ctx.scale(-1, 1);
                }
                
                // Draw the frame to canvas
                ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                
                // Reset transformation if applied
                if (cameraFacingMode === 'user') {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }
                
                // Convert to data URL
                const imageDataUrl = canvas.toDataURL('image/jpeg', 0.9);
                
                // Close the camera modal BEFORE any async operations
                closeFullScreenCameraModal();
                
                // Determine which preview element to update based on the target
                let previewElement, imageInput;
                
                if (imageTarget === 'modal') {
                    previewElement = imagePreview;
                    imageInput = imageBase64Input;
                } else if (imageTarget === 'fullframe') {
                    previewElement = fullFrameImagePreview;
                    imageInput = fullFrameImageBase64;
                } else {
                    console.error('Unknown image target:', imageTarget);
                    return;
                }
                
                // Show loading indicator with animation
                previewElement.innerHTML = `
                    <div class="loading-animation">
                        <div class="spinner-border text-primary spinner" role="status">
                            <span class="visually-hidden">Processing...</span>
                        </div>
                        <div class="message">Processing ${imageTarget === 'modal' ? 'category' : 'category'} image...</div>
                    </div>
                `;
                
                // Convert data URL to a Blob
                const response = await fetch(imageDataUrl);
                const blob = await response.blob();
                const file = new File([blob], `${imageTarget}-camera-image-${Date.now()}.jpg`, { type: "image/jpeg" });
                
                try {
                    // Get username from session/local storage
                    const username = sessionStorage.getItem('username') || localStorage.getItem('username') || 'admin';
                    
                    // Get Cloudinary credentials
                    const credentials = await getCloudinaryCredentials(username);
                    
                    if (!credentials || !credentials.cloud_name || !credentials.upload_preset) {
                        throw new Error('Invalid Cloudinary credentials');
                    }
                    
                    // Upload to Cloudinary
                    const cloudinaryUrl = await uploadToCloudinary(
                        file,
                        credentials.cloud_name,
                        credentials.upload_preset
                    );
                    
                    // Update the preview with the uploaded image
                    if (imageTarget === 'modal') {
                        updateImagePreview(cloudinaryUrl);
                    } else {
                        updateFullFrameImagePreview(cloudinaryUrl);
                    }
                    
                    // Set the image URL input
                    imageInput.value = cloudinaryUrl;
                    
                    // Show success message
                    showToast('Image uploaded successfully!', false);
                    
                } catch (error) {
                    console.error('Error uploading to Cloudinary:', error);
                    showToast('Cloudinary upload failed. Using local image.', true);
                    
                    // Fallback to using local image if Cloudinary upload fails
                    if (imageTarget === 'modal') {
                        updateImagePreview(imageDataUrl);
                    } else {
                        updateFullFrameImagePreview(imageDataUrl);
                    }
                    
                    // Set the image URL input to the base64 data
                    imageInput.value = imageDataUrl;
                }
                
            } catch (error) {
                console.error('Error in main capture function:', error);
                showToast('Failed to capture image: ' + error.message, true);
            }
        }
    </script>
</body>
</html>